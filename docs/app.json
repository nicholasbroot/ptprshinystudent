[{"name":"app.R","content":"# app.R\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(jsonlite)\nlibrary(openssl)\nlibrary(shinyWidgets)\nlibrary(shinyjs)\n\nif (FALSE) {\n  library(munsell)\n}\n\nsource(\"utils.R\")\n# ---------------- UI ----------------\n\nui <- fluidPage(\n  useShinyjs(),\n  titlePanel(\"PTPR Simulated Data Generator\"),\n  fluidRow(\n    column(\n      width=6,\n      tabsetPanel(\n        tabPanel(\"1. Design\",\n                 radioButtons(\"design\", \"Design:\",\n                              choices = c(\"2 groups (between) x 3 times (within)\" = \"2x3\",\n                                          \"3 groups (between) x 2 times (within)\" = \"3x2\")),\n                 numericInput(\"n_per_group\", \"Participants per group:\", value = 30, min = 30, step = 1),\n                 radioButtons(\"genders\", \"Participant Gender:\",\n                              choices = c(\"All genders (no restrictions)\",\"Only males\",\"Only females\",\"Only non-binary/other\")),\n                 sliderInput(\"age_range\", \"Participant Age Range:\", min=1, max=100, value=c(18,60), step=1)\n        ),\n        tabPanel(\"2. DV\",\n                 textInput(\"dv_name\", \"Dependent Variable label:\",\"LSAS Score\"),\n                 uiOutput(\"dv_range_ui\"),\n                 uiOutput(\"time1_range_ui\"),\n                 uiOutput(\"decimal_places\")),\n        tabPanel(\"3. IV\",\n                 uiOutput(\"group_name_ui\"),\n                 uiOutput(\"time_name_ui\")),\n        tabPanel(\"4. Effects\",\n                 uiOutput(\"delta_sliders\")))\n    ),\n    column(\n      width=6,\n      wellPanel(\n        h4(\"Verify Predicted Effects\"),\n        helpText(\"This graph will update dynamically as you adjust the parameters in the four tabs on the left. Only download your data once this graph matches your expectations.\"),\n        plotOutput(\"mean_plot\", height = 300)\n      ),\n      wellPanel(\n        h4(\"Download Data\"),\n        helpText(\"Click the buttons below to simulate a dataset based on your specifications and download it as a CSV file. Only click this button after you have filled out and adjusted all the parameters on the four tabs (Design, DV, IV, Effects), and after you have verified that the Predicted Effects graph matches your expectations.\"),\n        actionButton(\"simulateData\", \"Simulate Data\"),\n        #hidden(downloadButton(\"downloadData\", \"Download Data\"))\n        hidden(uiOutput(\"downloadData\"))\n      )\n      \n    )\n  )\n)\n\n# ---------------- Server ----------------\n\n\"%||%\" <- function(a, b) if (!is.null(a)) a else b\n\nserver <- function(input, output, session) {\n  # Dynamic T1 range slider\n  output$time1_range_ui <- renderUI({\n    dv_range <- input$dv_range %||% c(0, 144)\n    \n    label_text <- if (!is.null(input$dv_name) && nzchar(input$dv_name)) {\n      paste0(\"Allowed \", input$dv_name, \" at T1:\")\n    } else {\n      \"Allowed DV at T1:\"\n    }\n    \n    sliderInput(\n      \"time1_range\", label_text,\n      min = dv_range[1], max = dv_range[2],\n      value = dv_range, step = 0.5,\n      dragRange = TRUE\n    )\n  })\n  \n  observeEvent(input$time1_range, {\n    dv_range <- input$dv_range %||% c(0, 144)\n    total_width <- diff(dv_range)\n    min_width <- total_width * 0.2  # minimum 20% of DV range\n    \n    val <- input$time1_range\n    if (length(val) == 2) {\n      width <- diff(val)\n      if (width < min_width) {\n        # Expand symmetrically if possible, otherwise push upper bound\n        mid <- mean(val)\n        lo <- mid - min_width / 2\n        hi <- mid + min_width / 2\n        \n        # clamp to DV limits\n        if (lo < dv_range[1]) {\n          lo <- dv_range[1]\n          hi <- lo + min_width\n        }\n        if (hi > dv_range[2]) {\n          hi <- dv_range[2]\n          lo <- hi - min_width\n        }\n        \n        updateSliderInput(session, \"time1_range\", value = c(lo, hi))\n      }\n    }\n  }, ignoreInit = TRUE)\n  \n  \n  # Decimal places\n  output$decimal_places <- renderUI({\n    scale_range <- diff(input$dv_range %||% c(0, 144))\n    label_text <- if (!is.null(input$dv_name) && nzchar(input$dv_name)) {\n      paste0(\"# of decimal places in \", input$dv_name)\n    } else {\n      \"# of decimal places in DV:\"\n    }\n    \n    decimals <- if (scale_range <= 7) {\n      2\n    } else if (scale_range <= 20) {\n      1\n    } else {\n      0\n    }\n    sliderInput(\"decimal_places\", label_text,\n                min = decimals, max = 3, value = decimals, step = 1)\n  })\n  \n  # DV Range\n  output$dv_range_ui <- renderUI({\n    label_text <- if (!is.null(input$dv_name) && nzchar(input$dv_name)) {\n      paste0(input$dv_name, \" Range:\")\n    } else {\n      \"DV Range:\"\n    }\n    \n    # Provide a stable default range\n    sliderInput(\"dv_range\", label_text,\n                min = 0, max = 200, value = c(0, 144))\n  })\n  \n  \n  # Group names\n  output$group_name_ui <- renderUI({\n    n_groups <- if (input$design == \"2x3\") 2 else 3\n    tagList(\n      lapply(seq_len(n_groups), function(g) {\n        textInput(paste0(\"group_name_\", g),\n                  label = paste(\"Group\", g, \"label:\"),\n                  value = paste0(\"G\", g))\n      })\n    )\n  })\n  \n  output$time_name_ui <- renderUI({\n    n_times <- if (input$design == \"2x3\") 3 else 2\n    tagList(\n      lapply(seq_len(n_times), function(t) {\n        textInput(paste0(\"time_name_\", t),\n                  label = paste(\"Time\", t, \"label:\"),\n                  value = paste0(\"T\", t))\n      })\n    )\n  })\n  \n  r_labels <- reactive({\n    n_groups <- if (input$design == \"2x3\") 2 else 3\n    n_times  <- if (input$design == \"2x3\") 3 else 2\n    list(\n      groups = sapply(seq_len(n_groups), function(g) input[[paste0(\"group_name_\", g)]] %||% paste0(\"G\", g)),\n      times  = sapply(seq_len(n_times),  function(t) input[[paste0(\"time_name_\", t)]] %||% paste0(\"T\", t))\n    )\n  })\n  \n  # Sliders for deltas\n  # Sliders for deltas (now using user-provided labels)\n  output$delta_sliders <- renderUI({\n    # Determine number of groups/times based on design\n    if (input$design == \"2x3\") {\n      n_groups <- 2\n      n_times  <- 3\n    } else {\n      n_groups <- 3\n      n_times  <- 2\n    }\n    \n    # Fetch labels (fall back to defaults if not yet defined)\n    labels <- list(\n      groups = sapply(seq_len(n_groups), function(g)\n        input[[paste0(\"group_name_\", g)]] %||% paste0(\"G\", g)),\n      times = sapply(seq_len(n_times), function(t)\n        input[[paste0(\"time_name_\", t)]] %||% paste0(\"T\", t))\n    )\n    \n    # Create human-readable step labels like \"Time1 â†’ Time2\"\n    step_labels <- sapply(seq_len(n_times - 1), function(i) {\n      paste0(\"Predicted change \", labels$times[i], \" â†’ \", labels$times[i + 1])\n    })\n    \n    # Build sliders\n    tagList(\n      lapply(seq_len(n_groups), function(g) {\n        tagList(\n          tags$h4(paste0(\"Predictions for \", labels$groups[g]), \" Group\"),\n          lapply(seq_along(step_labels), function(s) {\n            sliderTextInput(\n              paste0(\"delta_g\", g, \"_s\", s),\n              label = step_labels[s],\n              choices = c(\n                \"--\",\n                \"-\",\n                \"0\",\n                \"+\",\n                \"++\"\n              ),\n              selected = \"0\",\n              hide_min_max = TRUE,\n              grid = TRUE\n            )\n          })\n        )\n      })\n    )\n  })\n  \n  \n  # Config reactive\n  r_cfg <- reactive({\n    valid_range_or <- function(x, default) {\n      if (is.null(x) || length(x) != 2 || anyNA(x)) default else x\n    }\n    \n    dv_range <- valid_range_or(input$dv_range, c(0,144))\n    t1_range <- valid_range_or(input$time1_range, dv_range)\n    age_range <- valid_range_or(input$age_range, c(18,60))\n    \n    make_config(\n      design = input$design %||% \"2x3\",\n      dv_range = dv_range,\n      t1_range = t1_range,\n      n_per_group = input$n_per_group %||% 30,\n      decimal_places = input$decimal_places %||% 0,\n      genders = input$genders %||% \"All genders (no restrictions)\",\n      age_range = age_range,\n      labels = r_labels()\n    )\n    \n  })\n  \n  \n  # Delta matrix from sliders\n  delta_mat <- reactive({\n    if (r_cfg()$design == \"2x3\") { G <- 2; steps <- 2 } else { G <- 3; steps <- 1 }\n    mat <- matrix(0, nrow = G, ncol = steps)\n    for (g in seq_len(G)) {\n      for (s in seq_len(steps)) {\n        val <- case_match(input[[paste0(\"delta_g\", g, \"_s\", s)]] %||% \"0\",\n                          \"--\" ~ -2,\n                          \"-\"  ~ -1,\n                          \"0\"  ~ 0,\n                          \"+\"  ~ 1,\n                          \"++\" ~ 2,\n                          .default = 0)\n        mat[g, s] <- val\n      }\n    }\n    \n    # ðŸ‘‰ normalize once across the whole matrix\n    mat <- normalize_deltas(mat)\n    mat\n  })\n  \n  \n  \n  # Preview means (deterministic, no noise)\n  preview_means <- reactive({\n    cfg <- r_cfg()\n    G <- if (cfg$design == \"2x3\") 2 else 3\n    t1 <- rep(mean(c(cfg$t1_lo, cfg$t1_hi)), G)\n    build_mean_matrix(cfg$design, t1, delta_mat(), delta_scale = 5, labels = r_labels())\n  })\n  \n  output$mean_plot <- renderPlot({\n    dvname = if (!is.null(input$dv_name) && nzchar(input$dv_name)) input$dv_name else \"DV\"\n    M <- preview_means()\n    dfm <- as_tibble(M) %>%\n      mutate(group = rownames(M)) %>%\n      pivot_longer(-group, names_to = \"time\", values_to = \"mean\") %>%\n      mutate(\n        time = factor(time, levels = colnames(M)),\n        group = factor(group, levels = rownames(M))\n      )\n    ggplot(dfm, aes(x = time, y = mean+ (as.numeric(factor(group)) - 1) * 0.25, group = group, color = group)) + # slight y offset for visibility\n      geom_line(linewidth=1.5) + \n      geom_point(size = 2) +\n      labs(title = \"Your Predicted Effects\", y = dvname, x = \"Time\",color=\"Group\") +\n      theme_minimal(base_size=18)+\n      scale_y_continuous(expand = expansion(add = c(5, 5)))+\n      scale_color_brewer(type=\"qual\",palette=\"Dark2\")+\n      theme(axis.text.y=element_blank())\n  })\n  \n  # Simulate on button click\n  sim <- reactiveVal(NULL)\n  \n  observeEvent(input$simulateData, {\n    tryCatch({\n      s <- run_simulation(r_cfg(), delta_mat(), input$seed)\n      sim(s)\n      shinyjs::show(\"downloadData\")\n      showNotification(\"Simulation successful â€” ready to download.\", type = \"message\")\n    }, error = function(e) {\n      msg <- conditionMessage(e)\n      key <- sub(\".*\\\\n(ey.*)$\", \"\\\\1\", msg) # extract Base64 if included in stop() \n      shinyjs::hide(\"downloadData\")\n      if (nzchar(key)) { \n        runjs(paste0(\"navigator.clipboard.writeText('\", key, \"');\")) \n        showNotification(\"Simulation failed. An error code has been copied to your clipboard. Please send this code to n.root@uva.nl.\", type = \"error\", duration = 10)\n      } else { \n        showNotification(msg, type = \"error\", duration = 10) \n      }\n    })\n  })\n  \n  observeEvent({\n    r_cfg()\n    delta_mat()\n  }, {\n    sim(NULL)\n    shinyjs::hide(\"downloadData\")\n  }, ignoreInit = TRUE)\n  \n  \n  output$downloadData <- renderUI({\n    \n    \n    s <- sim()\n    req(s)\n    \n    df <- s$df\n    df$data_identifier <- s$key\n    \n    # --- Apply user-visible labels here ---\n    lbls <- r_labels()\n    g_default <- paste0(\"G\", seq_along(lbls$groups))\n    t_default <- paste0(\"T\", seq_along(lbls$times))\n    \n    df <- df %>%\n      mutate(\n        group = factor(group, levels = g_default, labels = lbls$groups),\n        time  = factor(time,  levels = t_default, labels = lbls$times)\n      )\n    \n    # --- Rename DV column if specified ---\n    dv_col <- make.names(input$dv_name)\n    if (!is.null(dv_col) && nzchar(dv_col)) {\n      df <- df %>% rename(!!dv_col := y)\n    }\n    \n    # write to a text connection\n    con <- textConnection(\"csv_text\", \"w\")\n    write.csv(df, con, row.names = FALSE)\n    close(con)\n    \n    # URL-encode and create download link\n    encoded <- URLencode(paste(csv_text, collapse = \"\\n\"), reserved = TRUE)\n    tags$a(\n      href = paste0(\"data:text/csv;charset=utf-8,\", encoded),\n      download = \"data.csv\",\n      \"Download CSV\"\n    )\n  })\n  \n  \n  \n  \n#   output$downloadData <- downloadHandler(\n#     filename = function() paste0(\"simulated_data_\", Sys.Date(), \".csv\"),\n#     content = function(file) {\n#       s <- sim()\n#       req(s)\n#       \n#       df <- s$df\n#       df$data_identifier <- s$key\n#       \n#       # --- Apply user-visible labels here ---\n#       lbls <- r_labels()\n#       g_default <- paste0(\"G\", seq_along(lbls$groups))\n#       t_default <- paste0(\"T\", seq_along(lbls$times))\n#       \n#       df <- df %>%\n#         mutate(\n#           group = factor(group, levels = g_default, labels = lbls$groups),\n#           time  = factor(time,  levels = t_default, labels = lbls$times)\n#         )\n#       \n#       # --- Rename DV column if specified ---\n#       dv_col <- make.names(input$dv_name)\n#       if (!is.null(dv_col) && nzchar(dv_col)) {\n#         df <- df %>% rename(!!dv_col := y)\n#       }\n#       \n#       write.csv(df, file, row.names = FALSE)\n#     }\n#   )\n#   \n   \n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"PTPRShinyStudent.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"},{"name":"utils.R","content":"# ---------------- Utility functions ----------------\n\n# Testing design matrix perturbations for a new result\nequality_pattern <- function(D) {\n  C <- t(apply(D, 1, function(x) cumsum(c(0, x))))\n  vec <- as.vector(round(C, 8))\n  outer(vec, vec, FUN = \"==\")\n}\n\nperturbation_is_new_pattern <- function(D1, D2) {\n  !identical(equality_pattern(D1), equality_pattern(D2))\n}\n\n\n# Make config from reactive input\nmake_config <- function(design, dv_range, t1_range, n_per_group, decimal_places, genders, age_range, labels) {\n  list(\n    design = design,\n    dv_lo = dv_range[1],\n    dv_hi = dv_range[2],\n    t1_lo = t1_range[1],\n    t1_hi = t1_range[2],\n    n_per_group = n_per_group,\n    decimal_places = decimal_places,\n    genders = genders,\n    age_range = age_range,\n    labels = labels\n  )\n}\n\n# Normalize matrix in case user does ++ when they don't need to\n# Build cumulative offsets (expected means up to an additive baseline per group)\n.cum_offsets <- function(D) t(apply(D, 1, function(x) cumsum(c(0, x))))\n\n# Boolean equality pattern among ALL groupÃ—time means (captures within & between)\n.eq_pattern <- function(D, tol = 1e-8) {\n  C <- .cum_offsets(D)\n  v <- as.vector(C)\n  abs(outer(v, v, `-`)) <= tol\n}\n\n# Topology-preserving normalization: shrink magnitudes to the minimal integers\n# while preserving the equality/inequality pattern. Changes one cell per step.\nnormalize_deltas <- function(mat, tol = 1e-8) {\n  repeat {\n    base_pat <- .eq_pattern(mat, tol)\n    G <- nrow(mat); S <- ncol(mat)\n    \n    best <- mat\n    best_score <- sum(abs(mat))\n    improved <- FALSE\n    \n    for (g in 1:G) {\n      for (s in 1:S) {\n        v <- mat[g, s]\n        if (v == 0) next\n        sgn <- sign(v)\n        mag <- abs(v)\n        \n        # try shrinking this single cell by 1 (but not below 1)\n        if (mag > 1) {\n          cand <- mat\n          cand[g, s] <- sgn * (mag - 1)\n          if (identical(.eq_pattern(cand, tol), base_pat)) {\n            score <- sum(abs(cand))\n            if (score < best_score) {\n              best <- cand\n              best_score <- score\n              improved <- TRUE\n            }\n          }\n        }\n      }\n    }\n    \n    if (!improved) break\n    mat <- best\n  }\n  mat\n}\n\n\n\n# Draw age range\ndraw_age <- function(n, age_min, age_max) {\n  shape1 <- 2\n  shape2 <- 3\n  scaled <- rbeta(n, shape1, shape2)\n  round(age_min + scaled * (age_max - age_min))\n}\n\n# Expected topology of choice matrix\nexpected_topology <- function(design, delta_mat) {\n  # Within\n  exp_within <- list()\n  if (design == \"2x3\") {\n    for (g in 1:2) {\n      exp_within <- append(exp_within, list(data.frame(group=paste0(\"G\",g),\"contrast\"=\"T1 vs T2\",expect=delta_mat[g,1]!=0)))\n      exp_within <- append(exp_within, list(data.frame(group=paste0(\"G\",g),\"contrast\"=\"T2 vs T3\",expect=delta_mat[g,2]!=0)))\n      exp_within <- append(exp_within, list(data.frame(group=paste0(\"G\",g),\"contrast\"=\"T1 vs T3\",expect=(delta_mat[g,1]+delta_mat[g,2])!=0)))\n    }\n    G <- 2; times <- 3\n  } else {\n    for (g in 1:3) {\n      exp_within <- append(exp_within, list(data.frame(group=paste0(\"G\",g),\"contrast\"=\"T1 vs T2\",expect=delta_mat[g,1]!=0)))\n    }\n    G <- 3; times <- 2\n  }\n  expected_within <- do.call(rbind, exp_within)\n  \n  # Between (using cumulative deltas)\n  cum_deltas <- t(apply(delta_mat, 1, function(x) cumsum(c(0, x))))\n  exp_between <- data.frame()\n  for (t in 1:times) {\n    for (g1 in 1:(G-1)) for (g2 in (g1+1):G) {\n      diff_val <- cum_deltas[g1,t] - cum_deltas[g2,t]\n      expect <- if (t == 1) FALSE else diff_val != 0\n      exp_between <- rbind(exp_between, data.frame(time=paste0(\"T\",t),\n                                                   contrast=paste0(\"G\",g1,\" vs G\",g2),\n                                                   expect=expect))\n    }\n  }\n  list(within = expected_within, between = exp_between)\n}\n\n\n# Run simulation\nrun_simulation <- function(cfg, delta_mat, seed_input) {\n  seed0 <- if (!is.null(seed_input) && !is.na(seed_input) && seed_input > 0) {\n    seed_input\n  } else {\n    sample.int(.Machine$integer.max, 1)\n  }\n  \n  key_data <- list(\n    design         = cfg$design,\n    dv_lo          = cfg$dv_lo,\n    dv_hi          = cfg$dv_hi,\n    t1_lo          = cfg$t1_lo,\n    t1_hi          = cfg$t1_hi,\n    n_per_group    = cfg$n_per_group,\n    decimal_places = cfg$decimal_places,\n    genders        = cfg$genders,\n    age_range      = cfg$age_range,\n    delta_mat      = as.data.frame(delta_mat),\n    base_seed      = seed0,\n    labels         = cfg$labels\n  )\n  key_json <- jsonlite::toJSON(key_data, auto_unbox = TRUE)\n  key <- openssl::base64_encode(charToRaw(key_json))\n  \n  for (attempt in 1:500) {\n    seed_try <- seed0 + attempt - 1\n    set.seed(seed_try, kind = \"Mersenne-Twister\", normal.kind = \"Inversion\")\n    \n    # ---- Dynamic noise scaling based on direction of expected effects ----\n    noise_frac <- runif(1, 0.1, 0.3)\n    \n    usable_per_group <- numeric(nrow(delta_mat))\n    for (g in seq_len(nrow(delta_mat))) {\n      deltas_g <- delta_mat[g, ]\n      has_up   <- any(deltas_g > 0)\n      has_down <- any(deltas_g < 0)\n      \n      upper_room <- cfg$dv_hi - mean(c(cfg$t1_hi,cfg$t1_lo))\n      lower_room <- mean(c(cfg$t1_hi,cfg$t1_lo)) - cfg$dv_lo\n      \n      if (has_up && !has_down) {\n        usable_per_group[g] <- upper_room\n      } else if (has_down && !has_up) {\n        usable_per_group[g] <- lower_room\n      } else {\n        usable_per_group[g] <- min(upper_room, lower_room)\n      }\n    }\n    \n    \n    \n    # Conservative: use smallest headroom across groups; or mean() for smoother\n    usable_span <- min(usable_per_group)\n    \n    # Add small safeguard in case user-defined ranges leave zero room\n    usable_span <- max(usable_span, (cfg$dv_hi - cfg$dv_lo) * 0.05)\n    \n    noise_sd <- noise_frac * usable_span\n    \n    \n    G <- if (cfg$design == \"2x3\") 2 else 3\n    t1 <- default_t1_means(G, cfg$t1_lo, cfg$t1_hi, jitter_sd = 0.2)\n    \n    dz_min <- required_dz_min(cfg$design, cfg$n_per_group, alpha = 0.05)\n    dz_target <- runif(1, min = max(0.9,dz_min * 1.05), max = 1.2)\n    sd_diff <- sqrt(2 * (1 - 0.6)) * noise_sd # adjust 0.6 to match rho, if needed\n    delta_scale <- dz_target * sd_diff\n    \n    surprise <- introduce_unexpected(\n      delta_mat   = delta_mat,\n      cfg         = cfg,\n      t1          = t1,\n      delta_scale = delta_scale,\n      n_per_group = cfg$n_per_group,\n      dv_lo       = cfg$dv_lo,\n      dv_hi       = cfg$dv_hi,\n      noise_sd    = noise_sd,\n      seed        = seed_try\n    )\n    \n    if (!is.null(surprise)) {\n      \n      key_data$seed <- seed_try\n      key_json <- jsonlite::toJSON(key_data, auto_unbox = TRUE)\n      key <- openssl::base64_encode(charToRaw(key_json))\n      \n      return(list(\n        key         = key,\n        seed        = seed_try,\n        base_seed   = seed0,\n        attempt     = attempt,\n        noise_sd    = noise_sd,\n        dz_target   = dz_target,\n        delta_scale = delta_scale,\n        M_expected  = surprise$M_expected,\n        M_actual    = surprise$M_actual,\n        df          = surprise$df,\n        within      = surprise$within,\n        between     = surprise$between,\n        surprise_loc= surprise$surprise_loc,\n        check_within       = surprise$check_within,\n        check_between      = surprise$check_between\n      ))\n    }\n  }\n  \n  stop(paste(\n    \"Could not generate a dataset after 500 tries.\\n\",\n    \"Please copy and send this key to n.root@uva.nl:\\n\",\n    key\n  ))\n  \n}\n\n\n# check whether results match expectations\ncheck_significance <- function(within, between, delta_mat, design) {\n  expected <- list()\n  \n  # ---- Within-subject expectations ----\n  if (design == \"2x3\") {\n    for (g in 1:2) {\n      expected <- append(expected, list(data.frame(\n        group = paste0(\"G\", g), contrast = \"T1 vs T2\",\n        expect = delta_mat[g, 1] != 0\n      )))\n      expected <- append(expected, list(data.frame(\n        group = paste0(\"G\", g), contrast = \"T2 vs T3\",\n        expect = delta_mat[g, 2] != 0\n      )))\n      expected <- append(expected, list(data.frame(\n        group = paste0(\"G\", g), contrast = \"T1 vs T3\",\n        expect = (delta_mat[g, 1] + delta_mat[g, 2]) != 0\n      )))\n    }\n  } else if (design == \"3x2\") {\n    for (g in 1:3) {\n      expected <- append(expected, list(data.frame(\n        group = paste0(\"G\", g), contrast = \"T1 vs T2\",\n        expect = delta_mat[g, 1] != 0\n      )))\n    }\n  }\n  expected_within <- do.call(rbind, expected)\n  \n  \n  \n  check_within <- merge(expected_within, within[, c(\"group\", \"contrast\", \"p_holm\",\"sig\")],\n                        by = c(\"group\", \"contrast\"), all.x = TRUE)\n  ok_within <- if (any(is.na(check_within$sig))) FALSE else all(check_within$expect == check_within$sig)\n  \n  # ---- Between-subject expectations ----\n  # Compute expected means per group Ã— time from delta_mat\n  if (design == \"2x3\") {\n    G <- 2; times <- 3\n  } else {\n    G <- 3; times <- 2\n  }\n  cum_deltas <- t(apply(delta_mat, 1, function(x) cumsum(c(0, x))))\n  # rows = groups, cols = times (1-based)\n  \n  exp_between <- data.frame()\n  for (t in 1:times) {\n    for (g1 in 1:(G-1)) {\n      for (g2 in (g1+1):G) {\n        diff_val <- cum_deltas[g1, t] - cum_deltas[g2, t]\n        expect <- if (t == 1) FALSE else diff_val != 0\n        exp_between <- rbind(exp_between, data.frame(\n          time = paste0(\"T\", t),\n          contrast = paste0(\"G\", g1, \" vs G\", g2),\n          expect = expect\n        ))\n      }\n    }\n  }\n  \n  check_between <- merge(exp_between, between[, c(\"time\", \"contrast\", \"p_holm\",\"sig\")],\n                         by = c(\"time\", \"contrast\"), all.x = TRUE)\n  \n  ok_between <- if (any(is.na(check_between$sig))) FALSE else all(check_between$expect == check_between$sig)\n  \n  list(\n    ok = ok_within && ok_between,\n    within_details = check_within,\n    between_details = check_between\n  )\n}\n\n# Unexpected result\nintroduce_unexpected <- function(delta_mat, cfg, t1, delta_scale,\n                                 n_per_group, dv_lo, dv_hi, noise_sd, seed, labels=NULL) {\n  set.seed(seed)\n  \n  for (attempt in 1:500) {\n    # candidate group Ã— step\n    G <- nrow(delta_mat); steps <- ncol(delta_mat)\n    candidates <- expand.grid(g = 1:G, s = 1:steps)\n    choice <- candidates[sample(nrow(candidates), 1), ]\n    \n    # # make a Â±1 step adjustment\n    # delta_actual <- delta_mat\n    # shift <- sample(c(-1, 1), 1)\n    # new_val <- delta_actual[choice$g, choice$s] + shift\n    # delta_actual[choice$g, choice$s] <- max(-2, min(2, new_val))\n    \n    # Work in mean-space: cumulative deltas relative to baseline 0\n    mean_mat <- t(apply(delta_mat, 1, cumsum))\n    dim(mean_mat) <- dim(delta_mat)  # ensure consistent shape\n    \n    # identify which mean to perturb (the chosen group/time)\n    shift <- sample(c(-1, 1), 1)\n    mean_mat[choice$g, choice$s] <- mean_mat[choice$g, choice$s] + shift\n    \n    # convert back to deltas\n    delta_actual <- t(apply(mean_mat, 1, function(x) c(x[1], diff(x))))\n    dim(delta_actual) <- dim(delta_mat)\n    \n    # clip delta range just as before\n    delta_actual <- pmax(-2, pmin(2, delta_actual))\n    dim(delta_actual) <- dim(delta_mat)\n    \n    # normalize both expected and actual\n    delta_norm_expected <- normalize_deltas(delta_mat)\n    delta_norm_actual   <- normalize_deltas(delta_actual)\n    delta_logic_expected <- sign(delta_mat)\n    delta_logic_actual   <- sign(delta_actual)\n    \n    if (!perturbation_is_new_pattern(delta_norm_expected,delta_norm_actual)) next  # not a meaningful surprise\n    \n    # update actual delta to normalized version for simulation\n    delta_actual <- delta_norm_actual\n    \n    # build matrices\n    M_expected <- build_mean_matrix(cfg$design, t1, delta_norm_expected, delta_scale, labels = labels)\n    M_actual   <- build_mean_matrix(cfg$design, t1, delta_actual,        delta_scale, labels = labels)\n    \n    # simulate\n    df <- simulate_dataset(M_actual, n_per_group, dv_lo, dv_hi, noise_sd, cfg$decimal_places, cfg$genders, cfg$age_range)\n    within_res  <- evaluate_within(df)\n    between_res <- evaluate_between(df)\n    \n    # check flips\n    flip_info <- check_significance(within_res, between_res, delta_actual, cfg$design)\n    \n    if (flip_info$ok) {\n      return(list(\n        M_expected = M_expected,\n        M_actual   = M_actual,\n        delta_expected = delta_mat,\n        delta_actual   = delta_actual,\n        df = df,\n        within = within_res,\n        between = between_res,\n        surprise_loc = choice,\n        check_within = flip_info$within_details,\n        check_between = flip_info$between_details\n      ))\n    }\n  }\n  stop(\"Could not generate result in 500 tries.\")\n}\n\n# Minimum paired-samples dz to ensure significance after multiple-comparison guard\nrequired_dz_min <- function(design, n_per_group, alpha = 0.05) {\n  # Within-family comparisons per group:\n  m <- if (design == \"2x3\") 3 else 1  # (T1 vs T2), (T1 vs T3), (T2 vs T3) vs. only (T1 vs T2)\n  df <- n_per_group - 1\n  # Bonferroni guard (<= Holm), two-tailed:\n  alpha_bonf <- alpha / m\n  tcrit <- qt(1 - alpha_bonf/2, df = df)\n  tcrit / sqrt(n_per_group)  # dz threshold\n}\n\n# Baseline means (RCT: same mean + small jitter)\ndefault_t1_means <- function(n_groups, lo, hi, jitter_sd = 0.2) {\n  common_mean <- mean(c(lo, hi))\n  common_mean + rnorm(n_groups, mean = 0, sd = jitter_sd)\n}\n\n# Build mean matrix\nbuild_mean_matrix <- function(design, t1_means, delta_mat, delta_scale, labels = NULL) {\n  # Determine number of times\n  default_times <- if (design == \"2x3\") c(\"T1\", \"T2\", \"T3\") else c(\"T1\", \"T2\")\n  times <- if (!is.null(labels)) labels$times else default_times\n  \n  G <- length(t1_means)\n  Tn <- length(times)\n  \n  # Determine group labels if provided\n  group_names <- if (!is.null(labels)) labels$groups else paste0(\"G\", seq_len(G))\n  \n  # Initialize matrix\n  M <- matrix(NA_real_, nrow = G, ncol = Tn, dimnames = list(group_names, times))\n  \n  # Fill columns incrementally\n  M[, times[1]] <- t1_means\n  if (Tn >= 2) {\n    M[, times[2]] <- M[, times[1]] + delta_scale * delta_mat[, 1]\n  }\n  if (Tn == 3) {\n    M[, times[3]] <- M[, times[2]] + delta_scale * delta_mat[, 2]\n  }\n  \n  M\n}\n\n# Simulate dataset from mean matrix\nsimulate_dataset <- function(\n    M, n_per_group, dv_lo, dv_hi, noise_sd,\n    decimals = 0,\n    genders = \"All genders (no restrictions)\",\n    age_range = c(18, 60),\n    rho=0.6, # set within participant correlation\n    mean_jitter_sd=0.2,\n    time_jitter_sd=0.1\n) {\n  G <- nrow(M)\n  times <- colnames(M)\n  Tn <- ncol(M)\n  \n  # --- apply matrix-wide mean jitter (kept out of preview) ---\n  if (time_jitter_sd > 0) {\n    eps_t <- rnorm(Tn, 0, time_jitter_sd)\n    M <- sweep(M, 2, eps_t, \"+\")\n  }\n  if (mean_jitter_sd > 0) {\n    M <- M + matrix(rnorm(G * Tn, 0, mean_jitter_sd), G, Tn)\n  }\n  \n  \n  gender_levels <- c(\"Female\", \"Male\", \"Nonbinary/Other\")\n  probs <- switch(genders,\n                  \"All genders (no restrictions)\" = c(0.55, 0.40, 0.05),\n                  \"Only males\" = c(0, 1, 0),\n                  \"Only females\" = c(1, 0, 0),\n                  \"Only non-binary/other\" = c(0, 0, 1)\n  )\n  gender_draws <- sample(gender_levels, G * n_per_group, replace = TRUE, prob = probs)\n  age_draws <- draw_age(G * n_per_group, age_range[1], age_range[2])\n  \n  # --- covariance matrix for repeated measures ---\n  Sigma <- matrix(rho, Tn, Tn)\n  diag(Sigma) <- 1\n  U <- chol(Sigma)                          # upper triangular\n  A <- noise_sd * U\n  \n  df <- map_dfr(seq_len(G), function(g) {\n    ids <- paste0(\"g\", g, \"_\", seq_len(n_per_group))\n    mu_vec <- M[g, ]\n    \n    # generate correlated residuals per participant\n    Z <- matrix(rnorm(n_per_group * Tn), n_per_group, Tn)\n    eps <- Z %*% A\n    \n    y <- sweep(eps, 2, mu_vec, \"+\")\n    y <- pmin(pmax(y, dv_lo), dv_hi)\n    \n    tibble(\n      id = rep(ids, each = Tn),\n      group = paste0(\"G\", g),\n      time = rep(times, times = n_per_group),\n      y = as.vector(t(y))\n    )\n  })\n  \n  df <- df %>%\n    mutate(y = round(y, decimals)) %>%\n    left_join(tibble(id = unique(df$id), gender = gender_draws, age = age_draws), by = \"id\") %>%\n    select(id, group, time, gender, age, y)\n  \n  df\n}\n\n# simulate_dataset <- function(M, n_per_group, dv_lo, dv_hi, noise_sd, decimals = 0,\n#                              genders = \"All genders (no restrictions)\", age_range = c(18, 60)) {\n#   G <- nrow(M); times <- colnames(M); Tn <- ncol(M)\n#   \n#   # --- draw demographics per participant ---\n#   gender_levels <- c(\"Female\", \"Male\", \"Nonbinary/Other\")\n#   probs <- switch(genders,\n#                   \"All genders (no restrictions)\" = c(0.55, 0.40, 0.05),\n#                   \"Only males\" = c(0, 1, 0),\n#                   \"Only females\" = c(1, 0, 0),\n#                   \"Only non-binary/other\" = c(0, 0, 1))\n#   gender_draws <- sample(gender_levels, G * n_per_group, replace = TRUE, prob = probs)\n#   \n#   age_draws <- draw_age(G * n_per_group, age_range[1], age_range[2])\n#   \n#   df <- map_dfr(seq_len(G), function(g) {\n#     ids <- paste0(\"g\", g, \"_\", seq_len(n_per_group))\n#     map_dfr(seq_len(Tn), function(ti) {\n#       tibble(\n#         id = ids,\n#         group = paste0(\"G\", g),\n#         time = times[ti],\n#         mean = M[g, ti]\n#       )\n#     })\n#   })\n#   \n#   # Simulate dependent variable (within-person)\n#   df <- df %>%\n#     group_by(id) %>%\n#     mutate(y = r_y(n(), mean, noise_sd, dv_lo, dv_hi)) %>%\n#     ungroup() %>%\n#     mutate(y = round(y, decimals))\n#   \n#   # Assign demographics per participant (not per row)\n#   demo <- tibble(\n#     id = unique(df$id),\n#     gender = gender_draws,\n#     age = age_draws\n#   )\n#   \n#   # Join once per participant\n#   df <- df %>%\n#     left_join(demo, by = \"id\") %>%\n#     select(id, group, time, gender, age, y)\n#   \n#   \n#   df\n# }\n\n\n\n# Between-group t-tests with Holm correction\nevaluate_between <- function(df, alpha = 0.05) {\n  times <- unique(df$time)\n  times <- times[order(times)]  # make sure T1, T2, T3 are ordered\n  \n  results <- list()\n  \n  for (t in times) {\n    subset_df <- df[df$time == t, ]\n    groups <- sort(unique(subset_df$group))\n    \n    if (length(groups) == 2) {\n      # Simple t-test\n      g1 <- groups[1]; g2 <- groups[2]\n      dat1 <- subset_df$y[subset_df$group == g1]\n      dat2 <- subset_df$y[subset_df$group == g2]\n      res <- t.test(dat1, dat2, var.equal = TRUE)\n      results <- append(results, list(data.frame(\n        time = t,\n        contrast = paste0(g1, \" vs \", g2),\n        p_raw = res$p.value\n      )))\n    } else {\n      posthoc <- pairwise.t.test(subset_df$y, subset_df$group, p.adjust.method = \"none\")\n      combs <- rownames(posthoc$p.value)\n      for (i in seq_along(combs)) {\n        for (j in seq_along(posthoc$p.value[i, ])) {\n          g1 <- combs[i]; g2 <- colnames(posthoc$p.value)[j]\n          pval <- posthoc$p.value[i, j]\n          if (!is.na(pval)) {\n            results <- append(results, list(data.frame(\n              time = t,\n              contrast = paste0(g2, \" vs \", g1),\n              p_raw = pval\n            )))\n          }\n        }\n      }\n    }\n  }\n  \n  results_df <- do.call(rbind, results)\n  \n  # Holm correction across all comparisons\n  results_df$p_holm <- p.adjust(results_df$p_raw, method = \"holm\")\n  results_df$sig <- results_df$p_holm < alpha\n  \n  results_df\n}\n\n\n# Within-group paired t-tests with Holm correction\nevaluate_within <- function(df) {\n  out <- df %>%\n    group_by(group) %>%\n    group_split()\n  results <- map_dfr(out, function(dg) {\n    times <- sort(unique(dg$time))\n    wide <- dg %>% pivot_wider(id_cols = id, names_from = time, values_from = y)\n    combs <- combn(times, 2, simplify = FALSE)\n    tib <- map_dfr(combs, function(cmb) {\n      t1 <- cmb[1]; t2 <- cmb[2]\n      x <- wide[[t1]]; y <- wide[[t2]]\n      tt <- t.test(x, y, paired = TRUE)\n      tibble(group = unique(dg$group),\n             contrast = paste0(t1, \" vs \", t2),\n             p_raw = tt$p.value)\n    })\n    tib$p_holm <- p.adjust(tib$p_raw, method = \"holm\")\n    tib\n  })\n  results %>% mutate(sig = p_holm < 0.05)\n}\n","type":"text"}]
